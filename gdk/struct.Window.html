<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `Window` struct in crate `gdk`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, Window">

    <title>gdk::Window - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>gdk</a></p><script>window.sidebarCurrent = {name: 'Window', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>gdk</a>::<wbr><a class='struct' href=''>Window</a></span><span class='out-of-band'><span id='render-detail'>
            <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                [<span class='inner'>&#x2212;</span>]
            </a>
        </span></span></h1>
<pre class='rust struct'>pub struct Window(_, _);</pre><div class='docblock'></div><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'><h4 id='method.new' class='method'><code>fn <a href='#method.new' class='fnname'>new</a>(parent: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>&gt;, attributes: &amp;Attributes) -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<div class='docblock'><p>Creates a new <code>Window</code> using the attributes from
<code>attributes</code>. See <code>WindowAttr</code> and <code>WindowAttributesType</code> for
more details. Note: to use this on displays other than the default
display, <code>parent</code> must be specified.</p>

<h2 id='parent' class='section-header'><a href='#parent'><code>parent</code></a></h2>
<p>a <code>Window</code>, or <code>None</code> to create the window as a child of
 the default root window for the default display.</p>

<h2 id='attributes' class='section-header'><a href='#attributes'><code>attributes</code></a></h2>
<p>attributes of the new window</p>

<h2 id='attributes_mask' class='section-header'><a href='#attributes_mask'><code>attributes_mask</code></a></h2>
<p>mask indicating which
 fields in <code>attributes</code> are valid</p>

<h1 id='returns' class='section-header'><a href='#returns'>Returns</a></h1>
<p>the new <code>Window</code></p>
</div><h4 id='method.get_window_type' class='method'><code>fn <a href='#method.get_window_type' class='fnname'>get_window_type</a>(&amp;self) -&gt; <a class='enum' href='../gdk/enum.WindowType.html' title='gdk::WindowType'>WindowType</a></code></h4>
<div class='docblock'><p>Gets the type of the window. See <code>WindowType</code>.</p>

<h1 id='returns-1' class='section-header'><a href='#returns-1'>Returns</a></h1>
<p>type of window</p>
</div><h4 id='method.get_display' class='method'><code>fn <a href='#method.get_display' class='fnname'>get_display</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Display.html' title='gdk::Display'>Display</a></code></h4>
<div class='docblock'><p>Gets the <code>Display</code> associated with a <code>Window</code>.</p>

<h1 id='returns-2' class='section-header'><a href='#returns-2'>Returns</a></h1>
<p>the <code>Display</code> associated with <code>self</code></p>
</div><h4 id='method.get_screen' class='method'><code>fn <a href='#method.get_screen' class='fnname'>get_screen</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Screen.html' title='gdk::Screen'>Screen</a></code></h4>
<div class='docblock'><p>Gets the <code>Screen</code> associated with a <code>Window</code>.</p>

<h1 id='returns-3' class='section-header'><a href='#returns-3'>Returns</a></h1>
<p>the <code>Screen</code> associated with <code>self</code></p>
</div><h4 id='method.get_visual' class='method'><code>fn <a href='#method.get_visual' class='fnname'>get_visual</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Visual.html' title='gdk::Visual'>Visual</a></code></h4>
<div class='docblock'><p>Gets the <code>Visual</code> describing the pixel format of <code>self</code>.</p>

<h1 id='returns-4' class='section-header'><a href='#returns-4'>Returns</a></h1>
<p>a <code>Visual</code></p>
</div><h4 id='method.show' class='method'><code>fn <a href='#method.show' class='fnname'>show</a>(&amp;self)</code></h4>
<div class='docblock'><p>Like <code>Window::show_unraised</code>, but also raises the window to the
top of the window stack (moves the window to the front of the
Z-order).</p>

<p>This function maps a window so it’s visible onscreen. Its opposite
is <code>Window::hide</code>.</p>

<p>When implementing a <code>GtkWidget</code>, you should call this function on the widget&#39;s
<code>Window</code> as part of the “map” method.</p>
</div><h4 id='method.show_unraised' class='method'><code>fn <a href='#method.show_unraised' class='fnname'>show_unraised</a>(&amp;self)</code></h4>
<div class='docblock'><p>Shows a <code>Window</code> onscreen, but does not modify its stacking
order. In contrast, <code>Window::show</code> will raise the window
to the top of the window stack.</p>

<p>On the X11 platform, in Xlib terms, this function calls
XMapWindow() (it also updates some internal GDK state, which means
that you can’t really use XMapWindow() directly on a GDK window).</p>
</div><h4 id='method.hide' class='method'><code>fn <a href='#method.hide' class='fnname'>hide</a>(&amp;self)</code></h4>
<div class='docblock'><p>For toplevel windows, withdraws them, so they will no longer be
known to the window manager; for all windows, unmaps them, so
they won’t be displayed. Normally done automatically as
part of <code>gtk_widget_hide</code>.</p>
</div><h4 id='method.is_destroyed' class='method'><code>fn <a href='#method.is_destroyed' class='fnname'>is_destroyed</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Check to see if a window is destroyed..</p>

<h1 id='returns-5' class='section-header'><a href='#returns-5'>Returns</a></h1>
<p><code>true</code> if the window is destroyed</p>
</div><h4 id='method.is_visible' class='method'><code>fn <a href='#method.is_visible' class='fnname'>is_visible</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Checks whether the window has been mapped (with <code>Window::show</code> or
<code>Window::show_unraised</code>).</p>

<h1 id='returns-6' class='section-header'><a href='#returns-6'>Returns</a></h1>
<p><code>true</code> if the window is mapped</p>
</div><h4 id='method.is_viewable' class='method'><code>fn <a href='#method.is_viewable' class='fnname'>is_viewable</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Check if the window and all ancestors of the window are
mapped. (This is not necessarily &quot;viewable&quot; in the X sense, since
we only check as far as we have GDK window parents, not to the root
window.)</p>

<h1 id='returns-7' class='section-header'><a href='#returns-7'>Returns</a></h1>
<p><code>true</code> if the window is viewable</p>
</div><h4 id='method.is_input_only' class='method'><code>fn <a href='#method.is_input_only' class='fnname'>is_input_only</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Determines whether or not the window is an input only window.</p>

<h1 id='returns-8' class='section-header'><a href='#returns-8'>Returns</a></h1>
<p><code>true</code> if <code>self</code> is input only</p>
</div><h4 id='method.is_shaped' class='method'><code>fn <a href='#method.is_shaped' class='fnname'>is_shaped</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Determines whether or not the window is shaped.</p>

<h1 id='returns-9' class='section-header'><a href='#returns-9'>Returns</a></h1>
<p><code>true</code> if <code>self</code> is shaped</p>
</div><h4 id='method.get_state' class='method'><code>fn <a href='#method.get_state' class='fnname'>get_state</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.WindowState.html' title='gdk::WindowState'>WindowState</a></code></h4>
<div class='docblock'><p>Gets the bitwise OR of the currently active window state flags,
from the <code>WindowState</code> enumeration.</p>

<h1 id='returns-10' class='section-header'><a href='#returns-10'>Returns</a></h1>
<p>window state bitfield</p>
</div><h4 id='method.withdraw' class='method'><code>fn <a href='#method.withdraw' class='fnname'>withdraw</a>(&amp;self)</code></h4>
<div class='docblock'><p>Withdraws a window (unmaps it and asks the window manager to forget about it).
This function is not really useful as <code>Window::hide</code> automatically
withdraws toplevel windows before hiding them.</p>
</div><h4 id='method.iconify' class='method'><code>fn <a href='#method.iconify' class='fnname'>iconify</a>(&amp;self)</code></h4>
<div class='docblock'><p>Asks to iconify (minimize) <code>self</code>. The window manager may choose
to ignore the request, but normally will honor it. Using
<code>gtk_window_iconify</code> is preferred, if you have a <code>GtkWindow</code> widget.</p>

<p>This function only makes sense when <code>self</code> is a toplevel window.</p>
</div><h4 id='method.deiconify' class='method'><code>fn <a href='#method.deiconify' class='fnname'>deiconify</a>(&amp;self)</code></h4>
<div class='docblock'><p>Attempt to deiconify (unminimize) <code>self</code>. On X11 the window manager may
choose to ignore the request to deiconify. When using GTK+,
use <code>gtk_window_deiconify</code> instead of the <code>Window</code> variant. Or better yet,
you probably want to use <code>gtk_window_present</code>, which raises the window, focuses it,
unminimizes it, and puts it on the current desktop.</p>
</div><h4 id='method.stick' class='method'><code>fn <a href='#method.stick' class='fnname'>stick</a>(&amp;self)</code></h4>
<div class='docblock'><p>“Pins” a window such that it’s on all workspaces and does not scroll
with viewports, for window managers that have scrollable viewports.
(When using <code>GtkWindow</code>, <code>gtk_window_stick</code> may be more useful.)</p>

<p>On the X11 platform, this function depends on window manager
support, so may have no effect with many window managers. However,
GDK will do the best it can to convince the window manager to stick
the window. For window managers that don’t support this operation,
there’s nothing you can do to force it to happen.</p>
</div><h4 id='method.unstick' class='method'><code>fn <a href='#method.unstick' class='fnname'>unstick</a>(&amp;self)</code></h4>
<div class='docblock'><p>Reverse operation for <code>Window::stick</code>; see <code>Window::stick</code>,
and <code>gtk_window_unstick</code>.</p>
</div><h4 id='method.maximize' class='method'><code>fn <a href='#method.maximize' class='fnname'>maximize</a>(&amp;self)</code></h4>
<div class='docblock'><p>Maximizes the window. If the window was already maximized, then
this function does nothing.</p>

<p>On X11, asks the window manager to maximize <code>self</code>, if the window
manager supports this operation. Not all window managers support
this, and some deliberately ignore it or don’t have a concept of
“maximized”; so you can’t rely on the maximization actually
happening. But it will happen with most standard window managers,
and GDK makes a best effort to get it to happen.</p>

<p>On Windows, reliably maximizes the window.</p>
</div><h4 id='method.unmaximize' class='method'><code>fn <a href='#method.unmaximize' class='fnname'>unmaximize</a>(&amp;self)</code></h4>
<div class='docblock'><p>Unmaximizes the window. If the window wasn’t maximized, then this
function does nothing.</p>

<p>On X11, asks the window manager to unmaximize <code>self</code>, if the
window manager supports this operation. Not all window managers
support this, and some deliberately ignore it or don’t have a
concept of “maximized”; so you can’t rely on the unmaximization
actually happening. But it will happen with most standard window
managers, and GDK makes a best effort to get it to happen.</p>

<p>On Windows, reliably unmaximizes the window.</p>
</div><h4 id='method.fullscreen' class='method'><code>fn <a href='#method.fullscreen' class='fnname'>fullscreen</a>(&amp;self)</code></h4>
<div class='docblock'><p>Moves the window into fullscreen mode. This means the
window covers the entire screen and is above any panels
or task bars.</p>

<p>If the window was already fullscreen, then this function does nothing.</p>

<p>On X11, asks the window manager to put <code>self</code> in a fullscreen
state, if the window manager supports this operation. Not all
window managers support this, and some deliberately ignore it or
don’t have a concept of “fullscreen”; so you can’t rely on the
fullscreenification actually happening. But it will happen with
most standard window managers, and GDK makes a best effort to get
it to happen.</p>
</div><h4 id='method.unfullscreen' class='method'><code>fn <a href='#method.unfullscreen' class='fnname'>unfullscreen</a>(&amp;self)</code></h4>
<div class='docblock'><p>Moves the window out of fullscreen mode. If the window was not
fullscreen, does nothing.</p>

<p>On X11, asks the window manager to move <code>self</code> out of the fullscreen
state, if the window manager supports this operation. Not all
window managers support this, and some deliberately ignore it or
don’t have a concept of “fullscreen”; so you can’t rely on the
unfullscreenification actually happening. But it will happen with
most standard window managers, and GDK makes a best effort to get
it to happen.</p>
</div><h4 id='method.get_fullscreen_mode' class='method'><code>fn <a href='#method.get_fullscreen_mode' class='fnname'>get_fullscreen_mode</a>(&amp;self) -&gt; <a class='enum' href='../gdk/enum.FullscreenMode.html' title='gdk::FullscreenMode'>FullscreenMode</a></code></h4>
<div class='docblock'><p>Obtains the <code>FullscreenMode</code> of the <code>self</code>.</p>

<p>Since: 3.8</p>

<h1 id='returns-11' class='section-header'><a href='#returns-11'>Returns</a></h1>
<p>The <code>FullscreenMode</code> applied to the window when fullscreen.</p>
</div><h4 id='method.set_fullscreen_mode' class='method'><code>fn <a href='#method.set_fullscreen_mode' class='fnname'>set_fullscreen_mode</a>(&amp;self, mode: <a class='enum' href='../gdk/enum.FullscreenMode.html' title='gdk::FullscreenMode'>FullscreenMode</a>)</code></h4>
<div class='docblock'><p>Specifies whether the <code>self</code> should span over all monitors (in a multi-head
setup) or only the current monitor when in fullscreen mode.</p>

<p>The <code>mode</code> argument is from the <code>FullscreenMode</code> enumeration.
If <code>FullscreenMode::AllMonitors</code> is specified, the fullscreen <code>self</code> will
span over all monitors from the <code>Screen</code>.</p>

<p>On X11, searches through the list of monitors from the <code>Screen</code> the ones
which delimit the 4 edges of the entire <code>Screen</code> and will ask the window
manager to span the <code>self</code> over these monitors.</p>

<p>If the XINERAMA extension is not available or not usable, this function
has no effect.</p>

<p>Not all window managers support this, so you can’t rely on the fullscreen
window to span over the multiple monitors when <code>FullscreenMode::AllMonitors</code>
is specified.</p>

<p>Since: 3.8</p>

<h2 id='mode' class='section-header'><a href='#mode'><code>mode</code></a></h2>
<p>fullscreen mode</p>
</div><h4 id='method.set_keep_above' class='method'><code>fn <a href='#method.set_keep_above' class='fnname'>set_keep_above</a>(&amp;self, setting: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Set if <code>self</code> must be kept above other windows. If the
window was already above, then this function does nothing.</p>

<p>On X11, asks the window manager to keep <code>self</code> above, if the window
manager supports this operation. Not all window managers support
this, and some deliberately ignore it or don’t have a concept of
“keep above”; so you can’t rely on the window being kept above.
But it will happen with most standard window managers,
and GDK makes a best effort to get it to happen.</p>

<h2 id='setting' class='section-header'><a href='#setting'><code>setting</code></a></h2>
<p>whether to keep <code>self</code> above other windows</p>
</div><h4 id='method.set_keep_below' class='method'><code>fn <a href='#method.set_keep_below' class='fnname'>set_keep_below</a>(&amp;self, setting: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Set if <code>self</code> must be kept below other windows. If the
window was already below, then this function does nothing.</p>

<p>On X11, asks the window manager to keep <code>self</code> below, if the window
manager supports this operation. Not all window managers support
this, and some deliberately ignore it or don’t have a concept of
“keep below”; so you can’t rely on the window being kept below.
But it will happen with most standard window managers,
and GDK makes a best effort to get it to happen.</p>

<h2 id='setting-1' class='section-header'><a href='#setting-1'><code>setting</code></a></h2>
<p>whether to keep <code>self</code> below other windows</p>
</div><h4 id='method.set_opacity' class='method'><code>fn <a href='#method.set_opacity' class='fnname'>set_opacity</a>(&amp;self, opacity: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Set <code>self</code> to render as partially transparent,
with opacity 0 being fully transparent and 1 fully opaque. (Values
of the opacity parameter are clamped to the [0,1] range.)</p>

<p>For toplevel windows this depends on support from the windowing system
that may not always be there. For instance, On X11, this works only on
X screens with a compositing manager running. On Wayland, there is no
per-window opacity value that the compositor would apply. Instead, use
<code>gdk_window_set_opaque_region (window, NULL)</code> to tell the compositor
that the entire window is (potentially) non-opaque, and draw your content
with alpha, or use <code>gtk_widget_set_opacity</code> to set an overall opacity
for your widgets.</p>

<p>For child windows this function only works for non-native windows.</p>

<p>For setting up per-pixel alpha topelevels, see <code>Screen::get_rgba_visual</code>,
and for non-toplevels, see <code>Window::set_composited</code>.</p>

<p>Support for non-toplevel windows was added in 3.8.</p>

<h2 id='opacity' class='section-header'><a href='#opacity'><code>opacity</code></a></h2>
<p>opacity</p>
</div><h4 id='method.set_composited' class='method'><code>fn <a href='#method.set_composited' class='fnname'>set_composited</a>(&amp;self, composited: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Sets a <code>Window</code> as composited, or unsets it. Composited
windows do not automatically have their contents drawn to
the screen. Drawing is redirected to an offscreen buffer
and an expose event is emitted on the parent of the composited
window. It is the responsibility of the parent’s expose handler
to manually merge the off-screen content onto the screen in
whatever way it sees fit.</p>

<p>It only makes sense for child windows to be composited; see
<code>Window::set_opacity</code> if you need translucent toplevel
windows.</p>

<p>An additional effect of this call is that the area of this
window is no longer clipped from regions marked for
invalidation on its parent. Draws done on the parent
window are also no longer clipped by the child.</p>

<p>This call is only supported on some systems (currently,
only X11 with new enough Xcomposite and Xdamage extensions).
You must call <code>Display::supports_composite</code> to check if
setting a window as composited is supported before
attempting to do so.</p>

<h1 id='deprecated-since-316' class='section-header'><a href='#deprecated-since-316'>Deprecated since 3.16</a></h1>
<p>Compositing is an outdated technology that
 only ever worked on X11.</p>

<h2 id='composited' class='section-header'><a href='#composited'><code>composited</code></a></h2>
<p><code>true</code> to set the window as composited</p>
</div><h4 id='method.get_composited' class='method'><code>fn <a href='#method.get_composited' class='fnname'>get_composited</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Determines whether <code>self</code> is composited.</p>

<p>See <code>Window::set_composited</code>.</p>

<h1 id='deprecated-since-316-1' class='section-header'><a href='#deprecated-since-316-1'>Deprecated since 3.16</a></h1>
<p>Compositing is an outdated technology that
 only ever worked on X11.</p>

<h1 id='returns-12' class='section-header'><a href='#returns-12'>Returns</a></h1>
<p><code>true</code> if the window is composited.</p>
</div><h4 id='method._move' class='method'><code>fn <a href='#method._move' class='fnname'>_move</a>(&amp;self, x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<h4 id='method.resize' class='method'><code>fn <a href='#method.resize' class='fnname'>resize</a>(&amp;self, width: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, height: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Resizes <code>self</code>; for toplevel windows, asks the window manager to resize
the window. The window manager may not allow the resize. When using GTK+,
use <code>gtk_window_resize</code> instead of this low-level GDK function.</p>

<p>Windows may not be resized below 1x1.</p>

<p>If you’re also planning to move the window, use <code>Window::move_resize</code>
to both move and resize simultaneously, for a nicer visual effect.</p>

<h2 id='width' class='section-header'><a href='#width'><code>width</code></a></h2>
<p>new width of the window</p>

<h2 id='height' class='section-header'><a href='#height'><code>height</code></a></h2>
<p>new height of the window</p>
</div><h4 id='method.move_resize' class='method'><code>fn <a href='#method.move_resize' class='fnname'>move_resize</a>(&amp;self, x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, width: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, height: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Equivalent to calling <code>Window::move</code> and <code>Window::resize</code>,
except that both operations are performed at once, avoiding strange
visual effects. (i.e. the user may be able to see the window first
move, then resize, if you don’t use <code>Window::move_resize</code>.)</p>

<h2 id='x' class='section-header'><a href='#x'><code>x</code></a></h2>
<p>new X position relative to window’s parent</p>

<h2 id='y' class='section-header'><a href='#y'><code>y</code></a></h2>
<p>new Y position relative to window’s parent</p>

<h2 id='width-1' class='section-header'><a href='#width-1'><code>width</code></a></h2>
<p>new width</p>

<h2 id='height-1' class='section-header'><a href='#height-1'><code>height</code></a></h2>
<p>new height</p>
</div><h4 id='method.scroll' class='method'><code>fn <a href='#method.scroll' class='fnname'>scroll</a>(&amp;self, dx: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, dy: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Scroll the contents of <code>self</code>, both pixels and children, by the
given amount. <code>self</code> itself does not move. Portions of the window
that the scroll operation brings in from offscreen areas are
invalidated. The invalidated region may be bigger than what would
strictly be necessary.</p>

<p>For X11, a minimum area will be invalidated if the window has no
subwindows, or if the edges of the window’s parent do not extend
beyond the edges of the window. In other cases, a multi-step process
is used to scroll the window which may produce temporary visual
artifacts and unnecessary invalidations.</p>

<h2 id='dx' class='section-header'><a href='#dx'><code>dx</code></a></h2>
<p>Amount to scroll in the X direction</p>

<h2 id='dy' class='section-header'><a href='#dy'><code>dy</code></a></h2>
<p>Amount to scroll in the Y direction</p>
</div><h4 id='method.has_native' class='method'><code>fn <a href='#method.has_native' class='fnname'>has_native</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Checks whether the window has a native window or not. Note that
you can use <code>Window::ensure_native</code> if a native window is needed.</p>

<h1 id='returns-13' class='section-header'><a href='#returns-13'>Returns</a></h1>
<p><code>true</code> if the <code>self</code> has a native window, <code>false</code> otherwise.</p>
</div><h4 id='method.ensure_native' class='method'><code>fn <a href='#method.ensure_native' class='fnname'>ensure_native</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Tries to ensure that there is a window-system native window for this
<code>Window</code>. This may fail in some situations, returning <code>false</code>.</p>

<p>Offscreen window and children of them can never have native windows.</p>

<p>Some backends may not support native child windows.</p>

<h1 id='returns-14' class='section-header'><a href='#returns-14'>Returns</a></h1>
<p><code>true</code> if the window has a native window, <code>false</code> otherwise</p>
</div><h4 id='method.reparent' class='method'><code>fn <a href='#method.reparent' class='fnname'>reparent</a>(&amp;self, new_parent: &amp;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>, x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Reparents <code>self</code> into the given <code>new_parent</code>. The window being
reparented will be unmapped as a side effect.</p>

<h2 id='new_parent' class='section-header'><a href='#new_parent'><code>new_parent</code></a></h2>
<p>new parent to move <code>self</code> into</p>

<h2 id='x-1' class='section-header'><a href='#x-1'><code>x</code></a></h2>
<p>X location inside the new parent</p>

<h2 id='y-1' class='section-header'><a href='#y-1'><code>y</code></a></h2>
<p>Y location inside the new parent</p>
</div><h4 id='method.raise' class='method'><code>fn <a href='#method.raise' class='fnname'>raise</a>(&amp;self)</code></h4>
<div class='docblock'><p>Raises <code>self</code> to the top of the Z-order (stacking order), so that
other windows with the same parent window appear below <code>self</code>.
This is true whether or not the windows are visible.</p>

<p>If <code>self</code> is a toplevel, the window manager may choose to deny the
request to move the window in the Z-order, <code>Window::raise</code> only
requests the restack, does not guarantee it.</p>
</div><h4 id='method.lower' class='method'><code>fn <a href='#method.lower' class='fnname'>lower</a>(&amp;self)</code></h4>
<div class='docblock'><p>Lowers <code>self</code> to the bottom of the Z-order (stacking order), so that
other windows with the same parent window appear above <code>self</code>.
This is true whether or not the other windows are visible.</p>

<p>If <code>self</code> is a toplevel, the window manager may choose to deny the
request to move the window in the Z-order, <code>Window::lower</code> only
requests the restack, does not guarantee it.</p>

<p>Note that <code>Window::show</code> raises the window again, so don’t call this
function before <code>Window::show</code>. (Try <code>Window::show_unraised</code>.)</p>
</div><h4 id='method.restack' class='method'><code>fn <a href='#method.restack' class='fnname'>restack</a>(&amp;self, sibling: &amp;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>, above: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Changes the position of <code>self</code> in the Z-order (stacking order), so that
it is above <code>sibling</code> (if <code>above</code> is <code>true</code>) or below <code>sibling</code> (if <code>above</code> is
<code>false</code>).</p>

<p>If <code>sibling</code> is <code>None</code>, then this either raises (if <code>above</code> is <code>true</code>) or
lowers the window.</p>

<p>If <code>self</code> is a toplevel, the window manager may choose to deny the
request to move the window in the Z-order, <code>Window::restack</code> only
requests the restack, does not guarantee it.</p>

<h2 id='sibling' class='section-header'><a href='#sibling'><code>sibling</code></a></h2>
<p>a <code>Window</code> that is a sibling of <code>self</code>, or <code>None</code></p>

<h2 id='above' class='section-header'><a href='#above'><code>above</code></a></h2>
<p>a boolean</p>
</div><h4 id='method.focus' class='method'><code>fn <a href='#method.focus' class='fnname'>focus</a>(&amp;self, timestamp: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>)</code></h4>
<div class='docblock'><p>Sets keyboard focus to <code>self</code>. In most cases, <code>gtk_window_present</code>
should be used on a <code>GtkWindow</code>, rather than calling this function.</p>

<h2 id='timestamp' class='section-header'><a href='#timestamp'><code>timestamp</code></a></h2>
<p>timestamp of the event triggering the window focus</p>
</div><h4 id='method.register_dnd' class='method'><code>fn <a href='#method.register_dnd' class='fnname'>register_dnd</a>(&amp;self)</code></h4>
<div class='docblock'><p>Registers a window as a potential drop destination.</p>
</div><h4 id='method.begin_resize_drag' class='method'><code>fn <a href='#method.begin_resize_drag' class='fnname'>begin_resize_drag</a>(&amp;self, edge: <a class='enum' href='../gdk/enum.WindowEdge.html' title='gdk::WindowEdge'>WindowEdge</a>, button: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, timestamp: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>)</code></h4>
<div class='docblock'><p>Begins a window resize operation (for a toplevel window).</p>

<p>This function assumes that the drag is controlled by the
client pointer device, use <code>Window::begin_resize_drag_for_device</code>
to begin a drag with a different device.</p>

<h2 id='edge' class='section-header'><a href='#edge'><code>edge</code></a></h2>
<p>the edge or corner from which the drag is started</p>

<h2 id='button' class='section-header'><a href='#button'><code>button</code></a></h2>
<p>the button being used to drag, or 0 for a keyboard-initiated drag</p>

<h2 id='root_x' class='section-header'><a href='#root_x'><code>root_x</code></a></h2>
<p>root window X coordinate of mouse click that began the drag</p>

<h2 id='root_y' class='section-header'><a href='#root_y'><code>root_y</code></a></h2>
<p>root window Y coordinate of mouse click that began the drag</p>

<h2 id='timestamp-1' class='section-header'><a href='#timestamp-1'><code>timestamp</code></a></h2>
<p>timestamp of mouse click that began the drag (use <code>gdk_event_get_time</code>)</p>
</div><h4 id='method.begin_resize_drag_for_device' class='method'><code>fn <a href='#method.begin_resize_drag_for_device' class='fnname'>begin_resize_drag_for_device</a>(&amp;self, edge: <a class='enum' href='../gdk/enum.WindowEdge.html' title='gdk::WindowEdge'>WindowEdge</a>, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>, button: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, timestamp: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>)</code></h4>
<div class='docblock'><p>Begins a window resize operation (for a toplevel window).
You might use this function to implement a “window resize grip,” for
example; in fact <code>GtkStatusbar</code> uses it. The function works best
with window managers that support the
<a href="http://www.freedesktop.org/Standards/wm-spec">Extended Window Manager Hints</a>
but has a fallback implementation for other window managers.</p>

<h2 id='edge-1' class='section-header'><a href='#edge-1'><code>edge</code></a></h2>
<p>the edge or corner from which the drag is started</p>

<h2 id='device' class='section-header'><a href='#device'><code>device</code></a></h2>
<p>the device used for the operation</p>

<h2 id='button-1' class='section-header'><a href='#button-1'><code>button</code></a></h2>
<p>the button being used to drag, or 0 for a keyboard-initiated drag</p>

<h2 id='root_x-1' class='section-header'><a href='#root_x-1'><code>root_x</code></a></h2>
<p>root window X coordinate of mouse click that began the drag</p>

<h2 id='root_y-1' class='section-header'><a href='#root_y-1'><code>root_y</code></a></h2>
<p>root window Y coordinate of mouse click that began the drag</p>

<h2 id='timestamp-2' class='section-header'><a href='#timestamp-2'><code>timestamp</code></a></h2>
<p>timestamp of mouse click that began the drag (use <code>gdk_event_get_time</code>)</p>
</div><h4 id='method.begin_move_drag' class='method'><code>fn <a href='#method.begin_move_drag' class='fnname'>begin_move_drag</a>(&amp;self, button: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, timestamp: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>)</code></h4>
<div class='docblock'><p>Begins a window move operation (for a toplevel window).</p>

<p>This function assumes that the drag is controlled by the
client pointer device, use <code>Window::begin_move_drag_for_device</code>
to begin a drag with a different device.</p>

<h2 id='button-2' class='section-header'><a href='#button-2'><code>button</code></a></h2>
<p>the button being used to drag, or 0 for a keyboard-initiated drag</p>

<h2 id='root_x-2' class='section-header'><a href='#root_x-2'><code>root_x</code></a></h2>
<p>root window X coordinate of mouse click that began the drag</p>

<h2 id='root_y-2' class='section-header'><a href='#root_y-2'><code>root_y</code></a></h2>
<p>root window Y coordinate of mouse click that began the drag</p>

<h2 id='timestamp-3' class='section-header'><a href='#timestamp-3'><code>timestamp</code></a></h2>
<p>timestamp of mouse click that began the drag</p>
</div><h4 id='method.begin_move_drag_for_device' class='method'><code>fn <a href='#method.begin_move_drag_for_device' class='fnname'>begin_move_drag_for_device</a>(&amp;self, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>, button: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, timestamp: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>)</code></h4>
<div class='docblock'><p>Begins a window move operation (for a toplevel window).
You might use this function to implement a “window move grip,” for
example. The function works best with window managers that support the
<a href="http://www.freedesktop.org/Standards/wm-spec">Extended Window Manager Hints</a>
but has a fallback implementation for other window managers.</p>

<h2 id='device-1' class='section-header'><a href='#device-1'><code>device</code></a></h2>
<p>the device used for the operation</p>

<h2 id='button-3' class='section-header'><a href='#button-3'><code>button</code></a></h2>
<p>the button being used to drag, or 0 for a keyboard-initiated drag</p>

<h2 id='root_x-3' class='section-header'><a href='#root_x-3'><code>root_x</code></a></h2>
<p>root window X coordinate of mouse click that began the drag</p>

<h2 id='root_y-3' class='section-header'><a href='#root_y-3'><code>root_y</code></a></h2>
<p>root window Y coordinate of mouse click that began the drag</p>

<h2 id='timestamp-4' class='section-header'><a href='#timestamp-4'><code>timestamp</code></a></h2>
<p>timestamp of mouse click that began the drag</p>
</div><h4 id='method.beep' class='method'><code>fn <a href='#method.beep' class='fnname'>beep</a>(&amp;self)</code></h4>
<div class='docblock'><p>Emits a short beep associated to <code>self</code> in the appropriate
display, if supported. Otherwise, emits a short beep on
the display just as <code>Display::beep</code>.</p>
</div><h4 id='method.get_scale_factor' class='method'><code>fn <a href='#method.get_scale_factor' class='fnname'>get_scale_factor</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a></code></h4>
<div class='docblock'><p>Returns the internal scale factor that maps from window coordiantes
to the actual device pixels. On traditional systems this is 1, but
on very high density outputs this can be a higher value (often 2).</p>

<p>A higher value means that drawing is automatically scaled up to
a higher resolution, so any code doing drawing will automatically look
nicer. However, if you are supplying pixel-based data the scale
value can be used to determine whether to use a pixel resource
with higher resolution data.</p>

<p>The scale of a window may change during runtime, if this happens
a configure event will be sent to the toplevel window.</p>

<p>Since: 3.10</p>

<h1 id='returns-15' class='section-header'><a href='#returns-15'>Returns</a></h1>
<p>the scale factor</p>
</div><h4 id='method.begin_paint_rect' class='method'><code>fn <a href='#method.begin_paint_rect' class='fnname'>begin_paint_rect</a>(&amp;self, rect: &amp;<a class='struct' href='../cairo_sys/struct.cairo_rectangle_int_t.html' title='cairo_sys::cairo_rectangle_int_t'>RectangleInt</a>)</code></h4>
<div class='docblock'><p>A convenience wrapper around <code>Window::begin_paint_region</code> which
creates a rectangular region for you. See
<code>Window::begin_paint_region</code> for details.</p>

<h2 id='rectangle' class='section-header'><a href='#rectangle'><code>rectangle</code></a></h2>
<p>rectangle you intend to draw to</p>
</div><h4 id='method.end_paint' class='method'><code>fn <a href='#method.end_paint' class='fnname'>end_paint</a>(&amp;self)</code></h4>
<div class='docblock'><p>Indicates that the backing store created by the most recent call
to <code>Window::begin_paint_region</code> should be copied onscreen and
deleted, leaving the next-most-recent backing store or no backing
store at all as the active paint region. See
<code>Window::begin_paint_region</code> for full details.</p>

<p>It is an error to call this function without a matching
<code>Window::begin_paint_region</code> first.</p>
</div><h4 id='method.invalidate_rect' class='method'><code>fn <a href='#method.invalidate_rect' class='fnname'>invalidate_rect</a>(&amp;self, rect: &amp;<a class='struct' href='../cairo_sys/struct.cairo_rectangle_int_t.html' title='cairo_sys::cairo_rectangle_int_t'>RectangleInt</a>, invalidate_children: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>A convenience wrapper around <code>Window::invalidate_region</code> which
invalidates a rectangular region. See
<code>Window::invalidate_region</code> for details.</p>

<h2 id='rect' class='section-header'><a href='#rect'><code>rect</code></a></h2>
<p>rectangle to invalidate or <code>None</code> to invalidate the whole
 window</p>

<h2 id='invalidate_children' class='section-header'><a href='#invalidate_children'><code>invalidate_children</code></a></h2>
<p>whether to also invalidate child windows</p>
</div><h4 id='method.freeze_updates' class='method'><code>fn <a href='#method.freeze_updates' class='fnname'>freeze_updates</a>(&amp;self)</code></h4>
<div class='docblock'><p>Temporarily freezes a window such that it won’t receive expose
events. The window will begin receiving expose events again when
<code>Window::thaw_updates</code> is called. If <code>Window::freeze_updates</code>
has been called more than once, <code>Window::thaw_updates</code> must be called
an equal number of times to begin processing exposes.</p>
</div><h4 id='method.thaw_updates' class='method'><code>fn <a href='#method.thaw_updates' class='fnname'>thaw_updates</a>(&amp;self)</code></h4>
<div class='docblock'><p>Thaws a window frozen with <code>Window::freeze_updates</code>.</p>
</div><h4 id='method.process_all_updates' class='method'><code>fn <a href='#method.process_all_updates' class='fnname'>process_all_updates</a>()</code></h4>
<div class='docblock'><p>Calls <code>Window::process_updates</code> for all windows (see <code>Window</code>)
in the application.</p>
</div><h4 id='method.process_updates' class='method'><code>fn <a href='#method.process_updates' class='fnname'>process_updates</a>(&amp;self, update_children: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Sends one or more expose events to <code>self</code>. The areas in each
expose event will cover the entire update area for the window (see
<code>Window::invalidate_region</code> for details). Normally GDK calls
<code>Window::process_all_updates</code> on your behalf, so there’s no
need to call this function unless you want to force expose events
to be delivered immediately and synchronously (vs. the usual
case, where GDK delivers them in an idle handler). Occasionally
this is useful to produce nicer scrolling behavior, for example.</p>

<h2 id='update_children' class='section-header'><a href='#update_children'><code>update_children</code></a></h2>
<p>whether to also process updates for child windows</p>
</div><h4 id='method.set_debug_updates' class='method'><code>fn <a href='#method.set_debug_updates' class='fnname'>set_debug_updates</a>(setting: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>With update debugging enabled, calls to
<code>Window::invalidate_region</code> clear the invalidated region of the
screen to a noticeable color, and GDK pauses for a short time
before sending exposes to windows during
<code>Window::process_updates</code>. The net effect is that you can see
the invalid region for each window and watch redraws as they
occur. This allows you to diagnose inefficiencies in your application.</p>

<p>In essence, because the GDK rendering model prevents all flicker,
if you are redrawing the same region 400 times you may never
notice, aside from noticing a speed problem. Enabling update
debugging causes GTK to flicker slowly and noticeably, so you can
see exactly what’s being redrawn when, in what order.</p>

<p>The --gtk-debug=updates command line option passed to GTK+ programs
enables this debug option at application startup time. That&#39;s
usually more useful than calling <code>Window::set_debug_updates</code>
yourself, though you might want to use this function to enable
updates sometime after application startup time.</p>

<h2 id='setting-2' class='section-header'><a href='#setting-2'><code>setting</code></a></h2>
<p><code>true</code> to turn on update debugging</p>
</div><h4 id='method.get_frame_clock' class='method'><code>fn <a href='#method.get_frame_clock' class='fnname'>get_frame_clock</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.FrameClock.html' title='gdk::FrameClock'>FrameClock</a></code></h4>
<div class='docblock'><p>Gets the frame clock for the window. The frame clock for a window
never changes unless the window is reparented to a new toplevel
window.</p>

<p>Since: 3.8</p>

<h1 id='returns-16' class='section-header'><a href='#returns-16'>Returns</a></h1>
<p>the frame clock</p>
</div><h4 id='method.set_user_data' class='method'><code>unsafe fn <a href='#method.set_user_data' class='fnname'>set_user_data</a>&lt;T&gt;(&amp;self, user_data: &amp;mut T)</code></h4>
<div class='docblock'><p>For most purposes this function is deprecated in favor of
<code>gobject::Object::set_data</code>. However, for historical reasons GTK+ stores
the <code>GtkWidget</code> that owns a <code>Window</code> as user data on the
<code>Window</code>. So, custom widget implementations should use
this function for that. If GTK+ receives an event for a <code>Window</code>,
and the user data for the window is non-<code>None</code>, GTK+ will assume the
user data is a <code>GtkWidget</code>, and forward the event to that widget.</p>

<h2 id='user_data' class='section-header'><a href='#user_data'><code>user_data</code></a></h2>
<p>user data</p>
</div><h4 id='method.set_override_redirect' class='method'><code>fn <a href='#method.set_override_redirect' class='fnname'>set_override_redirect</a>(&amp;self, override_redirect: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>An override redirect window is not under the control of the window manager.
This means it won’t have a titlebar, won’t be minimizable, etc. - it will
be entirely under the control of the application. The window manager
can’t see the override redirect window at all.</p>

<p>Override redirect should only be used for short-lived temporary
windows, such as popup menus. <code>GtkMenu</code> uses an override redirect
window in its implementation, for example.</p>

<h2 id='override_redirect' class='section-header'><a href='#override_redirect'><code>override_redirect</code></a></h2>
<p><code>true</code> if window should be override redirect</p>
</div><h4 id='method.set_accept_focus' class='method'><code>fn <a href='#method.set_accept_focus' class='fnname'>set_accept_focus</a>(&amp;self, accept_focus: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Setting <code>accept_focus</code> to <code>false</code> hints the desktop environment that the
window doesn’t want to receive input focus.</p>

<p>On X, it is the responsibility of the window manager to interpret this
hint. ICCCM-compliant window manager usually respect it.</p>

<h2 id='accept_focus' class='section-header'><a href='#accept_focus'><code>accept_focus</code></a></h2>
<p><code>true</code> if the window should receive input focus</p>
</div><h4 id='method.get_accept_focus' class='method'><code>fn <a href='#method.get_accept_focus' class='fnname'>get_accept_focus</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Determines whether or not the desktop environment shuld be hinted that
the window does not want to receive input focus.</p>

<h1 id='returns-17' class='section-header'><a href='#returns-17'>Returns</a></h1>
<p>whether or not the window should receive input focus.</p>
</div><h4 id='method.set_focus_on_map' class='method'><code>fn <a href='#method.set_focus_on_map' class='fnname'>set_focus_on_map</a>(&amp;self, focus_on_map: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Setting <code>focus_on_map</code> to <code>false</code> hints the desktop environment that the
window doesn’t want to receive input focus when it is mapped.
focus_on_map should be turned off for windows that aren’t triggered
interactively (such as popups from network activity).</p>

<p>On X, it is the responsibility of the window manager to interpret
this hint. Window managers following the freedesktop.org window
manager extension specification should respect it.</p>

<h2 id='focus_on_map' class='section-header'><a href='#focus_on_map'><code>focus_on_map</code></a></h2>
<p><code>true</code> if the window should receive input focus when mapped</p>
</div><h4 id='method.get_focus_on_map' class='method'><code>fn <a href='#method.get_focus_on_map' class='fnname'>get_focus_on_map</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Determines whether or not the desktop environment should be hinted that the
window does not want to receive input focus when it is mapped.</p>

<h1 id='returns-18' class='section-header'><a href='#returns-18'>Returns</a></h1>
<p>whether or not the window wants to receive input focus when
it is mapped.</p>
</div><h4 id='method.set_child_shapes' class='method'><code>fn <a href='#method.set_child_shapes' class='fnname'>set_child_shapes</a>(&amp;self)</code></h4>
<div class='docblock'><p>Sets the shape mask of <code>self</code> to the union of shape masks
for all children of <code>self</code>, ignoring the shape mask of <code>self</code>
itself. Contrast with <code>Window::merge_child_shapes</code> which includes
the shape mask of <code>self</code> in the masks to be merged.</p>
</div><h4 id='method.merge_child_shapes' class='method'><code>fn <a href='#method.merge_child_shapes' class='fnname'>merge_child_shapes</a>(&amp;self)</code></h4>
<div class='docblock'><p>Merges the shape masks for any child windows into the
shape mask for <code>self</code>. i.e. the union of all masks
for <code>self</code> and its children will become the new mask
for <code>self</code>. See <code>Window::shape_combine_region</code>.</p>

<p>This function is distinct from <code>Window::set_child_shapes</code>
because it includes <code>self</code>’s shape mask in the set of shapes to
be merged.</p>
</div><h4 id='method.set_child_input_shapes' class='method'><code>fn <a href='#method.set_child_input_shapes' class='fnname'>set_child_input_shapes</a>(&amp;self)</code></h4>
<div class='docblock'><p>Sets the input shape mask of <code>self</code> to the union of input shape masks
for all children of <code>self</code>, ignoring the input shape mask of <code>self</code>
itself. Contrast with <code>Window::merge_child_input_shapes</code> which includes
the input shape mask of <code>self</code> in the masks to be merged.</p>
</div><h4 id='method.merge_child_input_shapes' class='method'><code>fn <a href='#method.merge_child_input_shapes' class='fnname'>merge_child_input_shapes</a>(&amp;self)</code></h4>
<div class='docblock'><p>Merges the input shape masks for any child windows into the
input shape mask for <code>self</code>. i.e. the union of all input masks
for <code>self</code> and its children will become the new input mask
for <code>self</code>. See <code>Window::input_shape_combine_region</code>.</p>

<p>This function is distinct from <code>Window::set_child_input_shapes</code>
because it includes <code>self</code>’s input shape mask in the set of
shapes to be merged.</p>
</div><h4 id='method.set_static_gravities' class='method'><code>fn <a href='#method.set_static_gravities' class='fnname'>set_static_gravities</a>(&amp;self, use_static: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Used to set the bit gravity of the given window to static, and flag
it so all children get static subwindow gravity. This is used if you
are implementing scary features that involve deep knowledge of the
windowing system. Don’t worry about it.</p>

<h1 id='deprecated-since-316-2' class='section-header'><a href='#deprecated-since-316-2'>Deprecated since 3.16</a></h1>
<p>static gravities haven&#39;t worked on anything but X11
 for a long time.</p>

<h2 id='use_static' class='section-header'><a href='#use_static'><code>use_static</code></a></h2>
<p><code>true</code> to turn on static gravity</p>

<h1 id='returns-19' class='section-header'><a href='#returns-19'>Returns</a></h1>
<p><code>false</code></p>
</div><h4 id='method.set_title' class='method'><code>fn <a href='#method.set_title' class='fnname'>set_title</a>(&amp;self, title: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>Sets the title of a toplevel window, to be displayed in the titlebar.
If you haven’t explicitly set the icon name for the window
(using <code>Window::set_icon_name</code>), the icon name will be set to
<code>title</code> as well. <code>title</code> must be in UTF-8 encoding (as with all
user-readable strings in GDK/GTK+). <code>title</code> may not be <code>None</code>.</p>

<h2 id='title' class='section-header'><a href='#title'><code>title</code></a></h2>
<p>title of <code>self</code></p>
</div><h4 id='method.set_background_rgba' class='method'><code>fn <a href='#method.set_background_rgba' class='fnname'>set_background_rgba</a>(&amp;self, rgba: &amp;<a class='struct' href='../gdk/struct.RGBA.html' title='gdk::RGBA'>GdkRGBA</a>)</code></h4>
<div class='docblock'><p>Sets the background color of <code>self</code>.</p>

<p>See also <code>Window::set_background_pattern</code>.</p>

<h2 id='rgba' class='section-header'><a href='#rgba'><code>rgba</code></a></h2>
<p>a <code>RGBA</code> color</p>
</div><h4 id='method.set_cursor' class='method'><code>fn <a href='#method.set_cursor' class='fnname'>set_cursor</a>(&amp;self, cursor: &amp;<a class='struct' href='../gdk/struct.Cursor.html' title='gdk::Cursor'>Cursor</a>)</code></h4>
<div class='docblock'><p>Sets the default mouse pointer for a <code>Window</code>.</p>

<p>Note that <code>cursor</code> must be for the same display as <code>self</code>.</p>

<p>Use <code>Cursor::new_for_display</code> or <code>Cursor::new_from_pixbuf</code> to
create the cursor. To make the cursor invisible, use <code>CursorType::BlankCursor</code>.
Passing <code>None</code> for the <code>cursor</code> argument to <code>Window::set_cursor</code> means
that <code>self</code> will use the cursor of its parent window. Most windows
should use this default.</p>

<h2 id='cursor' class='section-header'><a href='#cursor'><code>cursor</code></a></h2>
<p>a cursor</p>
</div><h4 id='method.get_cursor' class='method'><code>fn <a href='#method.get_cursor' class='fnname'>get_cursor</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../gdk/struct.Cursor.html' title='gdk::Cursor'>Cursor</a>&gt;</code></h4>
<div class='docblock'><p>Retrieves a <code>Cursor</code> pointer for the cursor currently set on the
specified <code>Window</code>, or <code>None</code>. If the return value is <code>None</code> then
there is no custom cursor set on the specified window, and it is
using the cursor for its parent window.</p>

<h1 id='returns-20' class='section-header'><a href='#returns-20'>Returns</a></h1>
<p>a <code>Cursor</code>, or <code>None</code>. The
 returned object is owned by the <code>Window</code> and should not be
 unreferenced directly. Use <code>Window::set_cursor</code> to unset the
 cursor of the window</p>
</div><h4 id='method.get_user_data' class='method'><code>unsafe fn <a href='#method.get_user_data' class='fnname'>get_user_data</a>&lt;'a, T&gt;(&amp;'a self) -&gt; &amp;'a mut T</code></h4>
<div class='docblock'><p>Retrieves the user data for <code>self</code>, which is normally the widget
that <code>self</code> belongs to. See <code>Window::set_user_data</code>.</p>

<h2 id='data' class='section-header'><a href='#data'><code>data</code></a></h2>
<p>return location for user data</p>
</div><h4 id='method.get_geometry' class='method'><code>fn <a href='#method.get_geometry' class='fnname'>get_geometry</a>(&amp;self, x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, width: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, height: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Any of the return location arguments to this function may be <code>None</code>,
if you aren’t interested in getting the value of that field.</p>

<p>The X and Y coordinates returned are relative to the parent window
of <code>self</code>, which for toplevels usually means relative to the
window decorations (titlebar, etc.) rather than relative to the
root window (screen-size background window).</p>

<p>On the X11 platform, the geometry is obtained from the X server,
so reflects the latest position of <code>self</code>; this may be out-of-sync
with the position of <code>self</code> delivered in the most-recently-processed
<code>EventConfigure</code>. <code>Window::get_position</code> in contrast gets the
position from the most recent configure event.</p>

<p>Note: If <code>self</code> is not a toplevel, it is much better
to call <code>Window::get_position</code>, <code>Window::get_width</code> and
<code>Window::get_height</code> instead, because it avoids the roundtrip to
the X server and because these functions support the full 32-bit
coordinate space, whereas <code>Window::get_geometry</code> is restricted to
the 16-bit coordinates of X11.</p>

<h2 id='x-2' class='section-header'><a href='#x-2'><code>x</code></a></h2>
<p>return location for X coordinate of window (relative to its parent)</p>

<h2 id='y-2' class='section-header'><a href='#y-2'><code>y</code></a></h2>
<p>return location for Y coordinate of window (relative to its parent)</p>

<h2 id='width-2' class='section-header'><a href='#width-2'><code>width</code></a></h2>
<p>return location for width of window</p>

<h2 id='height-2' class='section-header'><a href='#height-2'><code>height</code></a></h2>
<p>return location for height of window</p>
</div><h4 id='method.set_geometry_hints' class='method'><code>fn <a href='#method.set_geometry_hints' class='fnname'>set_geometry_hints</a>(&amp;self, geometry: &amp;<a class='struct' href='../gdk_sys/struct.GdkGeometry.html' title='gdk_sys::GdkGeometry'>GdkGeometry</a>, geom_mask: <a class='struct' href='../gdk/struct.WindowHints.html' title='gdk::WindowHints'>WindowHints</a>)</code></h4>
<div class='docblock'><p>Sets the geometry hints for <code>self</code>. Hints flagged in <code>geom_mask</code>
are set, hints not flagged in <code>geom_mask</code> are unset.
To unset all hints, use a <code>geom_mask</code> of 0 and a <code>geometry</code> of <code>None</code>.</p>

<p>This function provides hints to the windowing system about
acceptable sizes for a toplevel window. The purpose of
this is to constrain user resizing, but the windowing system
will typically (but is not required to) also constrain the
current size of the window to the provided values and
constrain programatic resizing via <code>Window::resize</code> or
<code>Window::move_resize</code>.</p>

<p>Note that on X11, this effect has no effect on windows
of type <code>WindowType::Temp</code> or windows where override redirect
has been turned on via <code>Window::set_override_redirect</code>
since these windows are not resizable by the user.</p>

<p>Since you can’t count on the windowing system doing the
constraints for programmatic resizes, you should generally
call <code>Window::constrain_size</code> yourself to determine
appropriate sizes.</p>

<h2 id='geometry' class='section-header'><a href='#geometry'><code>geometry</code></a></h2>
<p>geometry hints</p>

<h2 id='geom_mask' class='section-header'><a href='#geom_mask'><code>geom_mask</code></a></h2>
<p>bitmask indicating fields of <code>geometry</code> to pay attention to</p>
</div><h4 id='method.get_width' class='method'><code>fn <a href='#method.get_width' class='fnname'>get_width</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a></code></h4>
<div class='docblock'><p>Returns the width of the given <code>self</code>.</p>

<p>On the X11 platform the returned size is the size reported in the
most-recently-processed configure event, rather than the current
size on the X server.</p>

<h1 id='returns-21' class='section-header'><a href='#returns-21'>Returns</a></h1>
<p>The width of <code>self</code></p>
</div><h4 id='method.get_height' class='method'><code>fn <a href='#method.get_height' class='fnname'>get_height</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a></code></h4>
<div class='docblock'><p>Returns the height of the given <code>self</code>.</p>

<p>On the X11 platform the returned size is the size reported in the
most-recently-processed configure event, rather than the current
size on the X server.</p>

<h1 id='returns-22' class='section-header'><a href='#returns-22'>Returns</a></h1>
<p>The height of <code>self</code></p>
</div><h4 id='method.set_modal_hint' class='method'><code>fn <a href='#method.set_modal_hint' class='fnname'>set_modal_hint</a>(&amp;self, modal: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>The application can use this hint to tell the window manager
that a certain window has modal behaviour. The window manager
can use this information to handle modal windows in a special
way.</p>

<p>You should only use this on windows for which you have
previously called <code>Window::set_transient_for</code></p>

<h2 id='modal' class='section-header'><a href='#modal'><code>modal</code></a></h2>
<p><code>true</code> if the window is modal, <code>false</code> otherwise.</p>
</div><h4 id='method.get_modal_hint' class='method'><code>fn <a href='#method.get_modal_hint' class='fnname'>get_modal_hint</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Determines whether or not the window manager is hinted that <code>self</code>
has modal behaviour.</p>

<h1 id='returns-23' class='section-header'><a href='#returns-23'>Returns</a></h1>
<p>whether or not the window has the modal hint set.</p>
</div><h4 id='method.set_type_hint' class='method'><code>fn <a href='#method.set_type_hint' class='fnname'>set_type_hint</a>(&amp;self, hint: <a class='enum' href='../gdk/enum.WindowTypeHint.html' title='gdk::WindowTypeHint'>WindowTypeHint</a>)</code></h4>
<div class='docblock'><p>The application can use this call to provide a hint to the window
manager about the functionality of a window. The window manager
can use this information when determining the decoration and behaviour
of the window.</p>

<p>The hint must be set before the window is mapped.</p>

<h2 id='hint' class='section-header'><a href='#hint'><code>hint</code></a></h2>
<p>A hint of the function this window will have</p>
</div><h4 id='method.get_type_hint' class='method'><code>fn <a href='#method.get_type_hint' class='fnname'>get_type_hint</a>(&amp;self) -&gt; <a class='enum' href='../gdk/enum.WindowTypeHint.html' title='gdk::WindowTypeHint'>WindowTypeHint</a></code></h4>
<div class='docblock'><p>This function returns the type hint set for a window.</p>

<h1 id='returns-24' class='section-header'><a href='#returns-24'>Returns</a></h1>
<p>The type hint set for <code>self</code></p>
</div><h4 id='method.set_shadow_width' class='method'><code>fn <a href='#method.set_shadow_width' class='fnname'>set_shadow_width</a>(&amp;self, left: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, right: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, top: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, bottom: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Newer GTK+ windows using client-side decorations use extra geometry
around their frames for effects like shadows and invisible borders.
Window managers that want to maximize windows or snap to edges need
to know where the extents of the actual frame lie, so that users
don’t feel like windows are snapping against random invisible edges.</p>

<p>Note that this property is automatically updated by GTK+, so this
function should only be used by applications which do not use GTK+
to create toplevel windows.</p>

<p>Since: 3.12</p>

<h2 id='left' class='section-header'><a href='#left'><code>left</code></a></h2>
<p>The left extent</p>

<h2 id='right' class='section-header'><a href='#right'><code>right</code></a></h2>
<p>The right extent</p>

<h2 id='top' class='section-header'><a href='#top'><code>top</code></a></h2>
<p>The top extent</p>

<h2 id='bottom' class='section-header'><a href='#bottom'><code>bottom</code></a></h2>
<p>The bottom extent</p>
</div><h4 id='method.set_skip_taskbar_hint' class='method'><code>fn <a href='#method.set_skip_taskbar_hint' class='fnname'>set_skip_taskbar_hint</a>(&amp;self, skips_taskbar: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Toggles whether a window should appear in a task list or window
list. If a window’s semantic type as specified with
<code>Window::set_type_hint</code> already fully describes the window, this
function should not be called in addition,
instead you should allow the window to be treated according to
standard policy for its semantic type.</p>

<h2 id='skips_taskbar' class='section-header'><a href='#skips_taskbar'><code>skips_taskbar</code></a></h2>
<p><code>true</code> to skip the taskbar</p>
</div><h4 id='method.set_skip_pager_hint' class='method'><code>fn <a href='#method.set_skip_pager_hint' class='fnname'>set_skip_pager_hint</a>(&amp;self, skips_pager: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Toggles whether a window should appear in a pager (workspace
switcher, or other desktop utility program that displays a small
thumbnail representation of the windows on the desktop). If a
window’s semantic type as specified with <code>Window::set_type_hint</code>
already fully describes the window, this function should
not be called in addition, instead you should
allow the window to be treated according to standard policy for
its semantic type.</p>

<h2 id='skips_pager' class='section-header'><a href='#skips_pager'><code>skips_pager</code></a></h2>
<p><code>true</code> to skip the pager</p>
</div><h4 id='method.set_urgency_hint' class='method'><code>fn <a href='#method.set_urgency_hint' class='fnname'>set_urgency_hint</a>(&amp;self, urgent: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Toggles whether a window needs the user&#39;s
urgent attention.</p>

<h2 id='urgent' class='section-header'><a href='#urgent'><code>urgent</code></a></h2>
<p><code>true</code> if the window is urgent</p>
</div><h4 id='method.get_position' class='method'><code>fn <a href='#method.get_position' class='fnname'>get_position</a>(&amp;self, x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Obtains the position of the window as reported in the
most-recently-processed <code>EventConfigure</code>. Contrast with
<code>Window::get_geometry</code> which queries the X server for the
current window position, regardless of which events have been
received or processed.</p>

<p>The position coordinates are relative to the window’s parent window.</p>

<h2 id='x-3' class='section-header'><a href='#x-3'><code>x</code></a></h2>
<p>X coordinate of window</p>

<h2 id='y-3' class='section-header'><a href='#y-3'><code>y</code></a></h2>
<p>Y coordinate of window</p>
</div><h4 id='method.get_root_origin' class='method'><code>fn <a href='#method.get_root_origin' class='fnname'>get_root_origin</a>(&amp;self, x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Obtains the top-left corner of the window manager frame in root
window coordinates.</p>

<h2 id='x-4' class='section-header'><a href='#x-4'><code>x</code></a></h2>
<p>return location for X position of window frame</p>

<h2 id='y-4' class='section-header'><a href='#y-4'><code>y</code></a></h2>
<p>return location for Y position of window frame</p>
</div><h4 id='method.get_frame_extents' class='method'><code>fn <a href='#method.get_frame_extents' class='fnname'>get_frame_extents</a>(&amp;self) -&gt; <a class='struct' href='../cairo_sys/struct.cairo_rectangle_int_t.html' title='cairo_sys::cairo_rectangle_int_t'>RectangleInt</a></code></h4>
<div class='docblock'><p>Obtains the bounding box of the window, including window manager
titlebar/borders if any. The frame position is given in root window
coordinates. To get the position of the window itself (rather than
the frame) in root window coordinates, use <code>Window::get_origin</code>.</p>

<h2 id='rect-1' class='section-header'><a href='#rect-1'><code>rect</code></a></h2>
<p>rectangle to fill with bounding box of the window frame</p>
</div><h4 id='method.get_origin' class='method'><code>fn <a href='#method.get_origin' class='fnname'>get_origin</a>(&amp;self, x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a></code></h4>
<div class='docblock'><p>Obtains the position of a window in root window coordinates.
(Compare with <code>Window::get_position</code> and
<code>Window::get_geometry</code> which return the position of a window
relative to its parent window.)</p>

<h2 id='x-5' class='section-header'><a href='#x-5'><code>x</code></a></h2>
<p>return location for X coordinate</p>

<h2 id='y-5' class='section-header'><a href='#y-5'><code>y</code></a></h2>
<p>return location for Y coordinate</p>

<h1 id='returns-25' class='section-header'><a href='#returns-25'>Returns</a></h1>
<p>not meaningful, ignore</p>
</div><h4 id='method.get_root_coords' class='method'><code>fn <a href='#method.get_root_coords' class='fnname'>get_root_coords</a>(&amp;self, x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, root_y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>)</code></h4>
<div class='docblock'><p>Obtains the position of a window position in root
window coordinates. This is similar to
<code>Window::get_origin</code> but allows you to pass
in any position in the window, not just the origin.</p>

<h2 id='x-6' class='section-header'><a href='#x-6'><code>x</code></a></h2>
<p>X coordinate in window</p>

<h2 id='y-6' class='section-header'><a href='#y-6'><code>y</code></a></h2>
<p>Y coordinate in window</p>

<h2 id='root_x-4' class='section-header'><a href='#root_x-4'><code>root_x</code></a></h2>
<p>return location for X coordinate</p>

<h2 id='root_y-4' class='section-header'><a href='#root_y-4'><code>root_y</code></a></h2>
<p>return location for Y coordinate</p>
</div><h4 id='method.get_device_position' class='method'><code>fn <a href='#method.get_device_position' class='fnname'>get_device_position</a>(&amp;self, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>, x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.i32.html'>i32</a>, mask: &amp;mut <a class='struct' href='../gdk/struct.ModifierType.html' title='gdk::ModifierType'>ModifierType</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>&gt;</code></h4>
<div class='docblock'><p>Obtains the current device position and modifier state.
The position is given in coordinates relative to the upper left
corner of <code>self</code>.</p>

<p>Use <code>Window::get_device_position_double</code> if you need subpixel precision.</p>

<h2 id='device-2' class='section-header'><a href='#device-2'><code>device</code></a></h2>
<p>pointer <code>Device</code> to query to.</p>

<h2 id='x-7' class='section-header'><a href='#x-7'><code>x</code></a></h2>
<p>return location for the X coordinate of <code>device</code>, or <code>None</code>.</p>

<h2 id='y-7' class='section-header'><a href='#y-7'><code>y</code></a></h2>
<p>return location for the Y coordinate of <code>device</code>, or <code>None</code>.</p>

<h2 id='mask' class='section-header'><a href='#mask'><code>mask</code></a></h2>
<p>return location for the modifier mask, or <code>None</code>.</p>

<h1 id='returns-26' class='section-header'><a href='#returns-26'>Returns</a></h1>
<p>The window underneath <code>device</code>
(as with <code>Device::get_window_at_position</code>), or <code>None</code> if the
window is not known to GDK.</p>
</div><h4 id='method.get_device_position_double' class='method'><code>fn <a href='#method.get_device_position_double' class='fnname'>get_device_position_double</a>(&amp;self, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>, x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, mask: &amp;mut <a class='struct' href='../gdk/struct.ModifierType.html' title='gdk::ModifierType'>ModifierType</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>&gt;</code></h4>
<div class='docblock'><p>Obtains the current device position in doubles and modifier state.
The position is given in coordinates relative to the upper left
corner of <code>self</code>.</p>

<p>Since: 3.10</p>

<h2 id='device-3' class='section-header'><a href='#device-3'><code>device</code></a></h2>
<p>pointer <code>Device</code> to query to.</p>

<h2 id='x-8' class='section-header'><a href='#x-8'><code>x</code></a></h2>
<p>return location for the X coordinate of <code>device</code>, or <code>None</code>.</p>

<h2 id='y-8' class='section-header'><a href='#y-8'><code>y</code></a></h2>
<p>return location for the Y coordinate of <code>device</code>, or <code>None</code>.</p>

<h2 id='mask-1' class='section-header'><a href='#mask-1'><code>mask</code></a></h2>
<p>return location for the modifier mask, or <code>None</code>.</p>

<h1 id='returns-27' class='section-header'><a href='#returns-27'>Returns</a></h1>
<p>The window underneath <code>device</code>
(as with <code>Device::get_window_at_position</code>), or <code>None</code> if the
window is not known to GDK.</p>
</div><h4 id='method.get_parent' class='method'><code>fn <a href='#method.get_parent' class='fnname'>get_parent</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<div class='docblock'><p>Obtains the parent of <code>self</code>, as known to GDK. Does not query the
X server; thus this returns the parent as passed to <code>Window::new</code>,
not the actual parent. This should never matter unless you’re using
Xlib calls mixed with GDK calls on the X11 platform. It may also
matter for toplevel windows, because the window manager may choose
to reparent them.</p>

<p>Note that you should use <code>Window::get_effective_parent</code> when
writing generic code that walks up a window hierarchy, because
<code>Window::get_parent</code> will most likely not do what you expect if
there are offscreen windows in the hierarchy.</p>

<h1 id='returns-28' class='section-header'><a href='#returns-28'>Returns</a></h1>
<p>parent of <code>self</code></p>
</div><h4 id='method.get_toplevel' class='method'><code>fn <a href='#method.get_toplevel' class='fnname'>get_toplevel</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<div class='docblock'><p>Gets the toplevel window that’s an ancestor of <code>self</code>.</p>

<p>Any window type but <code>WindowType::Child</code> is considered a
toplevel window, as is a <code>WindowType::Child</code> window that
has a root window as parent.</p>

<p>Note that you should use <code>Window::get_effective_toplevel</code> when
you want to get to a window’s toplevel as seen on screen, because
<code>Window::get_toplevel</code> will most likely not do what you expect
if there are offscreen windows in the hierarchy.</p>

<h1 id='returns-29' class='section-header'><a href='#returns-29'>Returns</a></h1>
<p>the toplevel window containing <code>self</code></p>
</div><h4 id='method.get_events' class='method'><code>fn <a href='#method.get_events' class='fnname'>get_events</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.EventMask.html' title='gdk::EventMask'>EventMask</a></code></h4>
<div class='docblock'><p>Gets the event mask for <code>self</code> for all master input devices. See
<code>Window::set_events</code>.</p>

<h1 id='returns-30' class='section-header'><a href='#returns-30'>Returns</a></h1>
<p>event mask for <code>self</code></p>
</div><h4 id='method.set_events' class='method'><code>fn <a href='#method.set_events' class='fnname'>set_events</a>(&amp;self, event_mask: <a class='struct' href='../gdk/struct.EventMask.html' title='gdk::EventMask'>EventMask</a>)</code></h4>
<div class='docblock'><p>The event mask for a window determines which events will be reported
for that window from all master input devices. For example, an event mask
including <code>EventMask::ButtonPressMask</code> means the window should report button
press events. The event mask is the bitwise OR of values from the
<code>EventMask</code> enumeration.</p>

<p>See the [input handling overview][event-masks] for details.</p>

<h2 id='event_mask' class='section-header'><a href='#event_mask'><code>event_mask</code></a></h2>
<p>event mask for <code>self</code></p>
</div><h4 id='method.set_icon_name' class='method'><code>fn <a href='#method.set_icon_name' class='fnname'>set_icon_name</a>(&amp;self, name: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>Windows may have a name used while minimized, distinct from the
name they display in their titlebar. Most of the time this is a bad
idea from a user interface standpoint. But you can set such a name
with this function, if you like.</p>

<p>After calling this with a non-<code>None</code> <code>name</code>, calls to <code>Window::set_title</code>
will not update the icon title.</p>

<p>Using <code>None</code> for <code>name</code> unsets the icon title; further calls to
<code>Window::set_title</code> will again update the icon title as well.</p>

<h2 id='name' class='section-header'><a href='#name'><code>name</code></a></h2>
<p>name of window while iconified (minimized)</p>
</div><h4 id='method.set_transient_for' class='method'><code>fn <a href='#method.set_transient_for' class='fnname'>set_transient_for</a>(&amp;self, parent: &amp;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>)</code></h4>
<div class='docblock'><p>Indicates to the window manager that <code>self</code> is a transient dialog
associated with the application window <code>parent</code>. This allows the
window manager to do things like center <code>self</code> on <code>parent</code> and
keep <code>self</code> above <code>parent</code>.</p>

<p>See <code>gtk_window_set_transient_for</code> if you’re using <code>GtkWindow</code> or
<code>GtkDialog</code>.</p>

<h2 id='parent-1' class='section-header'><a href='#parent-1'><code>parent</code></a></h2>
<p>another toplevel <code>Window</code></p>
</div><h4 id='method.set_role' class='method'><code>fn <a href='#method.set_role' class='fnname'>set_role</a>(&amp;self, role: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>When using GTK+, typically you should use <code>gtk_window_set_role</code> instead
of this low-level function.</p>

<p>The window manager and session manager use a window’s role to
distinguish it from other kinds of window in the same application.
When an application is restarted after being saved in a previous
session, all windows with the same title and role are treated as
interchangeable. So if you have two windows with the same title
that should be distinguished for session management purposes, you
should set the role on those windows. It doesn’t matter what string
you use for the role, as long as you have a different role for each
non-interchangeable kind of window.</p>

<h2 id='role' class='section-header'><a href='#role'><code>role</code></a></h2>
<p>a string indicating its role</p>
</div><h4 id='method.set_startup_id' class='method'><code>fn <a href='#method.set_startup_id' class='fnname'>set_startup_id</a>(&amp;self, startup_id: &amp;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.str.html'>str</a>)</code></h4>
<div class='docblock'><p>When using GTK+, typically you should use <code>gtk_window_set_startup_id</code>
instead of this low-level function.</p>

<h2 id='startup_id' class='section-header'><a href='#startup_id'><code>startup_id</code></a></h2>
<p>a string with startup-notification identifier</p>
</div><h4 id='method.set_group' class='method'><code>fn <a href='#method.set_group' class='fnname'>set_group</a>(&amp;self, leader: <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;&amp;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>&gt;)</code></h4>
<div class='docblock'><p>Sets the group leader window for <code>self</code>. By default,
GDK sets the group leader for all toplevel windows
to a global window implicitly created by GDK. With this function
you can override this default.</p>

<p>The group leader window allows the window manager to distinguish
all windows that belong to a single application. It may for example
allow users to minimize/unminimize all windows belonging to an
application at once. You should only set a non-default group window
if your application pretends to be multiple applications.</p>

<h2 id='leader' class='section-header'><a href='#leader'><code>leader</code></a></h2>
<p>group leader window, or <code>None</code> to restore the default group leader window</p>
</div><h4 id='method.get_group' class='method'><code>fn <a href='#method.get_group' class='fnname'>get_group</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<div class='docblock'><p>Returns the group leader window for <code>self</code>. See <code>Window::set_group</code>.</p>

<h1 id='returns-31' class='section-header'><a href='#returns-31'>Returns</a></h1>
<p>the group leader window for <code>self</code></p>
</div><h4 id='method.set_decorations' class='method'><code>fn <a href='#method.set_decorations' class='fnname'>set_decorations</a>(&amp;self, decorations: <a class='struct' href='../gdk/struct.WMDecoration.html' title='gdk::WMDecoration'>WMDecoration</a>)</code></h4>
<div class='docblock'><p>“Decorations” are the features the window manager adds to a toplevel <code>Window</code>.
This function sets the traditional Motif window manager hints that tell the
window manager which decorations you would like your window to have.
Usually you should use <code>gtk_window_set_decorated</code> on a <code>GtkWindow</code> instead of
using the GDK function directly.</p>

<p>The <code>decorations</code> argument is the logical OR of the fields in
the <code>WMDecoration</code> enumeration. If <code>WMDecoration::All</code> is included in the
mask, the other bits indicate which decorations should be turned off.
If <code>WMDecoration::All</code> is not included, then the other bits indicate
which decorations should be turned on.</p>

<p>Most window managers honor a decorations hint of 0 to disable all decorations,
but very few honor all possible combinations of bits.</p>

<h2 id='decorations' class='section-header'><a href='#decorations'><code>decorations</code></a></h2>
<p>decoration hint mask</p>
</div><h4 id='method.get_decorations' class='method'><code>fn <a href='#method.get_decorations' class='fnname'>get_decorations</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../gdk/struct.WMDecoration.html' title='gdk::WMDecoration'>WMDecoration</a>&gt;</code></h4>
<div class='docblock'><p>Returns the decorations set on the <code>Window</code> with
<code>Window::set_decorations</code>.</p>

<h2 id='decorations-1' class='section-header'><a href='#decorations-1'><code>decorations</code></a></h2>
<p>The window decorations will be written here</p>

<h1 id='returns-32' class='section-header'><a href='#returns-32'>Returns</a></h1>
<p><code>true</code> if the window has decorations set, <code>false</code> otherwise.</p>
</div><h4 id='method.set_functions' class='method'><code>fn <a href='#method.set_functions' class='fnname'>set_functions</a>(&amp;self, functions: <a class='struct' href='../gdk/struct.WMFunction.html' title='gdk::WMFunction'>WMFunction</a>)</code></h4>
<div class='docblock'><p>Sets hints about the window management functions to make available
via buttons on the window frame.</p>

<p>On the X backend, this function sets the traditional Motif window
manager hint for this purpose. However, few window managers do
anything reliable or interesting with this hint. Many ignore it
entirely.</p>

<p>The <code>functions</code> argument is the logical OR of values from the
<code>WMFunction</code> enumeration. If the bitmask includes <code>WMFunction::All</code>,
then the other bits indicate which functions to disable; if
it doesn’t include <code>WMFunction::All</code>, it indicates which functions to
enable.</p>

<h2 id='functions' class='section-header'><a href='#functions'><code>functions</code></a></h2>
<p>bitmask of operations to allow on <code>self</code></p>
</div><h4 id='method.get_default_root_window' class='method'><code>fn <a href='#method.get_default_root_window' class='fnname'>get_default_root_window</a>() -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<h4 id='method.get_support_multidevice' class='method'><code>fn <a href='#method.get_support_multidevice' class='fnname'>get_support_multidevice</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Returns <code>true</code> if the window is aware of the existence of multiple
devices.</p>

<h1 id='returns-33' class='section-header'><a href='#returns-33'>Returns</a></h1>
<p><code>true</code> if the window handles multidevice features.</p>
</div><h4 id='method.set_support_multidevice' class='method'><code>fn <a href='#method.set_support_multidevice' class='fnname'>set_support_multidevice</a>(&amp;self, support_multidevice: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>This function will enable multidevice features in <code>self</code>.</p>

<p>Multidevice aware windows will need to handle properly multiple,
per device enter/leave events, device grabs and grab ownerships.</p>

<h2 id='support_multidevice' class='section-header'><a href='#support_multidevice'><code>support_multidevice</code></a></h2>
<p><code>true</code> to enable multidevice support in <code>self</code>.</p>
</div><h4 id='method.get_device_cursor' class='method'><code>fn <a href='#method.get_device_cursor' class='fnname'>get_device_cursor</a>(&amp;self, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../gdk/struct.Cursor.html' title='gdk::Cursor'>Cursor</a>&gt;</code></h4>
<div class='docblock'><p>Retrieves a <code>Cursor</code> pointer for the <code>device</code> currently set on the
specified <code>Window</code>, or <code>None</code>. If the return value is <code>None</code> then
there is no custom cursor set on the specified window, and it is
using the cursor for its parent window.</p>

<h2 id='device-4' class='section-header'><a href='#device-4'><code>device</code></a></h2>
<p>a master, pointer <code>Device</code>.</p>

<h1 id='returns-34' class='section-header'><a href='#returns-34'>Returns</a></h1>
<p>a <code>Cursor</code>, or <code>None</code>. The
 returned object is owned by the <code>Window</code> and should not be
 unreferenced directly. Use <code>Window::set_cursor</code> to unset the
 cursor of the window</p>
</div><h4 id='method.set_device_cursor' class='method'><code>fn <a href='#method.set_device_cursor' class='fnname'>set_device_cursor</a>(&amp;self, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>, cursor: &amp;<a class='struct' href='../gdk/struct.Cursor.html' title='gdk::Cursor'>Cursor</a>)</code></h4>
<div class='docblock'><p>Sets a specific <code>Cursor</code> for a given device when it gets inside <code>self</code>.
Use <code>Cursor::new_for_display</code> or <code>Cursor::new_from_pixbuf</code> to create
the cursor. To make the cursor invisible, use <code>CursorType::BlankCursor</code>. Passing
<code>None</code> for the <code>cursor</code> argument to <code>Window::set_cursor</code> means that
<code>self</code> will use the cursor of its parent window. Most windows should
use this default.</p>

<h2 id='device-5' class='section-header'><a href='#device-5'><code>device</code></a></h2>
<p>a master, pointer <code>Device</code></p>

<h2 id='cursor-1' class='section-header'><a href='#cursor-1'><code>cursor</code></a></h2>
<p>a <code>Cursor</code></p>
</div><h4 id='method.get_device_events' class='method'><code>fn <a href='#method.get_device_events' class='fnname'>get_device_events</a>(&amp;self, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>) -&gt; <a class='struct' href='../gdk/struct.EventMask.html' title='gdk::EventMask'>EventMask</a></code></h4>
<div class='docblock'><p>Returns the event mask for <code>self</code> corresponding to an specific device.</p>

<h2 id='device-6' class='section-header'><a href='#device-6'><code>device</code></a></h2>
<p>a <code>Device</code>.</p>

<h1 id='returns-35' class='section-header'><a href='#returns-35'>Returns</a></h1>
<p>device event mask for <code>self</code></p>
</div><h4 id='method.set_device_events' class='method'><code>fn <a href='#method.set_device_events' class='fnname'>set_device_events</a>(&amp;self, device: &amp;<a class='struct' href='../gdk/struct.Device.html' title='gdk::Device'>Device</a>, event_mask: <a class='struct' href='../gdk/struct.EventMask.html' title='gdk::EventMask'>EventMask</a>)</code></h4>
<div class='docblock'><p>Sets the event mask for a given device (Normally a floating device, not
attached to any visible pointer) to <code>self</code>. For example, an event mask
including <code>EventMask::ButtonPressMask</code> means the window should report button
press events. The event mask is the bitwise OR of values from the
<code>EventMask</code> enumeration.</p>

<p>See the [input handling overview][event-masks] for details.</p>

<h2 id='device-7' class='section-header'><a href='#device-7'><code>device</code></a></h2>
<p><code>Device</code> to enable events for.</p>

<h2 id='event_mask-1' class='section-header'><a href='#event_mask-1'><code>event_mask</code></a></h2>
<p>event mask for <code>self</code></p>
</div><h4 id='method.get_source_events' class='method'><code>fn <a href='#method.get_source_events' class='fnname'>get_source_events</a>(&amp;self, source: <a class='enum' href='../gdk/enum.InputSource.html' title='gdk::InputSource'>InputSource</a>) -&gt; <a class='struct' href='../gdk/struct.EventMask.html' title='gdk::EventMask'>EventMask</a></code></h4>
<div class='docblock'><p>Returns the event mask for <code>self</code> corresponding to the device class specified
by <code>source</code>.</p>

<h2 id='source' class='section-header'><a href='#source'><code>source</code></a></h2>
<p>a <code>InputSource</code> to define the source class.</p>

<h1 id='returns-36' class='section-header'><a href='#returns-36'>Returns</a></h1>
<p>source event mask for <code>self</code></p>
</div><h4 id='method.set_source_events' class='method'><code>fn <a href='#method.set_source_events' class='fnname'>set_source_events</a>(&amp;self, source: <a class='enum' href='../gdk/enum.InputSource.html' title='gdk::InputSource'>InputSource</a>, event_mask: <a class='struct' href='../gdk/struct.EventMask.html' title='gdk::EventMask'>EventMask</a>)</code></h4>
<div class='docblock'><p>Sets the event mask for any floating device (i.e. not attached to any
visible pointer) that has the source defined as <code>source</code>. This event
mask will be applied both to currently existing, newly added devices
after this call, and devices being attached/detached.</p>

<h2 id='source-1' class='section-header'><a href='#source-1'><code>source</code></a></h2>
<p>a <code>InputSource</code> to define the source class.</p>

<h2 id='event_mask-2' class='section-header'><a href='#event_mask-2'><code>event_mask</code></a></h2>
<p>event mask for <code>self</code></p>
</div><h4 id='method.get_event_compression' class='method'><code>fn <a href='#method.get_event_compression' class='fnname'>get_event_compression</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Get the current event compression setting for this window.</p>

<p>Since: 3.12</p>

<h1 id='returns-37' class='section-header'><a href='#returns-37'>Returns</a></h1>
<p><code>true</code> if motion events will be compressed</p>
</div><h4 id='method.set_event_compression' class='method'><code>fn <a href='#method.set_event_compression' class='fnname'>set_event_compression</a>(&amp;self, event_compression: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a>)</code></h4>
<div class='docblock'><p>Determines whether or not extra unprocessed motion events in
the event queue can be discarded. If <code>true</code> only the most recent
event will be delivered.</p>

<p>Some types of applications, e.g. paint programs, need to see all
motion events and will benefit from turning off event compression.</p>

<p>By default, event compression is enabled.</p>

<p>Since: 3.12</p>

<h2 id='event_compression' class='section-header'><a href='#event_compression'><code>event_compression</code></a></h2>
<p><code>true</code> if motion events should be compressed</p>
</div><h4 id='method.offscreen_window_set_embedder' class='method'><code>fn <a href='#method.offscreen_window_set_embedder' class='fnname'>offscreen_window_set_embedder</a>(&amp;self, embedder: &amp;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>)</code></h4>
<h4 id='method.offscreen_window_get_embedder' class='method'><code>fn <a href='#method.offscreen_window_get_embedder' class='fnname'>offscreen_window_get_embedder</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>&gt;</code></h4>
<h4 id='method.geometry_changed' class='method'><code>fn <a href='#method.geometry_changed' class='fnname'>geometry_changed</a>(&amp;self)</code></h4>
<div class='docblock'><p>This function informs GDK that the geometry of an embedded
offscreen window has changed. This is necessary for GDK to keep
track of which offscreen window the pointer is in.</p>
</div><h4 id='method.coords_from_parent' class='method'><code>fn <a href='#method.coords_from_parent' class='fnname'>coords_from_parent</a>(&amp;self, parent_x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, parent_y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Transforms window coordinates from a parent window to a child
window, where the parent window is the normal parent as returned by
<code>Window::get_parent</code> for normal windows, and the window&#39;s
embedder as returned by <code>gdk_offscreen_window_get_embedder</code> for
offscreen windows.</p>

<p>For normal windows, calling this function is equivalent to subtracting
the return values of <code>Window::get_position</code> from the parent coordinates.
For offscreen windows however (which can be arbitrarily transformed),
this function calls the <code>Window</code>::from-embedder: signal to translate
the coordinates.</p>

<p>You should always use this function when writing generic code that
walks down a window hierarchy.</p>

<p>See also: <code>Window::coords_to_parent</code></p>

<h2 id='parent_x' class='section-header'><a href='#parent_x'><code>parent_x</code></a></h2>
<p>X coordinate in parent’s coordinate system</p>

<h2 id='parent_y' class='section-header'><a href='#parent_y'><code>parent_y</code></a></h2>
<p>Y coordinate in parent’s coordinate system</p>

<h2 id='x-9' class='section-header'><a href='#x-9'><code>x</code></a></h2>
<p>return location for X coordinate in child’s coordinate system</p>

<h2 id='y-9' class='section-header'><a href='#y-9'><code>y</code></a></h2>
<p>return location for Y coordinate in child’s coordinate system</p>
</div><h4 id='method.coords_to_parent' class='method'><code>fn <a href='#method.coords_to_parent' class='fnname'>coords_to_parent</a>(&amp;self, x: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, y: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, parent_x: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>, parent_y: &amp;mut <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.f64.html'>f64</a>)</code></h4>
<div class='docblock'><p>Transforms window coordinates from a child window to its parent
window, where the parent window is the normal parent as returned by
<code>Window::get_parent</code> for normal windows, and the window&#39;s
embedder as returned by <code>gdk_offscreen_window_get_embedder</code> for
offscreen windows.</p>

<p>For normal windows, calling this function is equivalent to adding
the return values of <code>Window::get_position</code> to the child coordinates.
For offscreen windows however (which can be arbitrarily transformed),
this function calls the <code>Window</code>::to-embedder: signal to translate
the coordinates.</p>

<p>You should always use this function when writing generic code that
walks up a window hierarchy.</p>

<p>See also: <code>Window::coords_from_parent</code></p>

<h2 id='x-10' class='section-header'><a href='#x-10'><code>x</code></a></h2>
<p>X coordinate in child’s coordinate system</p>

<h2 id='y-10' class='section-header'><a href='#y-10'><code>y</code></a></h2>
<p>Y coordinate in child’s coordinate system</p>

<h2 id='parent_x-1' class='section-header'><a href='#parent_x-1'><code>parent_x</code></a></h2>
<p>return location for X coordinate
in parent’s coordinate system, or <code>None</code></p>

<h2 id='parent_y-1' class='section-header'><a href='#parent_y-1'><code>parent_y</code></a></h2>
<p>return location for Y coordinate
in parent’s coordinate system, or <code>None</code></p>
</div><h4 id='method.get_effective_parent' class='method'><code>fn <a href='#method.get_effective_parent' class='fnname'>get_effective_parent</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<div class='docblock'><p>Obtains the parent of <code>self</code>, as known to GDK. Works like
<code>Window::get_parent</code> for normal windows, but returns the
window’s embedder for offscreen windows.</p>

<p>See also: <code>gdk_offscreen_window_get_embedder</code></p>

<h1 id='returns-38' class='section-header'><a href='#returns-38'>Returns</a></h1>
<p>effective parent of <code>self</code></p>
</div><h4 id='method.get_effective_toplevel' class='method'><code>fn <a href='#method.get_effective_toplevel' class='fnname'>get_effective_toplevel</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<div class='docblock'><p>Gets the toplevel window that’s an ancestor of <code>self</code>.</p>

<p>Works like <code>Window::get_toplevel</code>, but treats an offscreen window&#39;s
embedder as its parent, using <code>Window::get_effective_parent</code>.</p>

<p>See also: <code>gdk_offscreen_window_get_embedder</code></p>

<h1 id='returns-39' class='section-header'><a href='#returns-39'>Returns</a></h1>
<p>the effective toplevel window containing <code>self</code></p>
</div><h4 id='method.get_drag_protocol' class='method'><code>fn <a href='#method.get_drag_protocol' class='fnname'>get_drag_protocol</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>(</a><a class='enum' href='../gdk/enum.DragProtocol.html' title='gdk::DragProtocol'>DragProtocol</a>, <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a>&gt;<a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.tuple.html'>)</a></code></h4>
<div class='docblock'><p>Finds out the DND protocol supported by a window.</p>

<h2 id='target' class='section-header'><a href='#target'><code>target</code></a></h2>
<p>location of the window
 where the drop should happen. This may be <code>self</code> or a proxy window,
 or <code>None</code> if <code>self</code> does not support Drag and Drop.</p>

<h1 id='returns-40' class='section-header'><a href='#returns-40'>Returns</a></h1>
<p>the supported DND protocol.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl <a class='trait' href='../glib/types/trait.StaticType.html' title='glib::types::StaticType'>StaticType</a> for <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'><h4 id='method.static_type' class='method'><code>fn <a href='../glib/types/trait.StaticType.html#method.static_type' class='fnname'>static_type</a>() -&gt; <a class='enum' href='../glib/types/enum.Type.html' title='glib::types::Type'>Type</a></code></h4>
</div><h3 class='impl'><code>impl&lt;T: <a class='trait' href='../glib/object/trait.IsA.html' title='glib::object::IsA'>IsA</a>&lt;<a class='struct' href='../glib/object/struct.Object.html' title='glib::object::Object'>Object</a>&gt;&gt; <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html' title='core::cmp::PartialEq'>PartialEq</a>&lt;T&gt; for <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'><h4 id='method.eq' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.eq' class='fnname'>eq</a>(&amp;self, other: &amp;T) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<h4 id='method.ne' class='method'><span class="since">1.0.0</span><code>fn <a href='https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html#method.ne' class='fnname'>ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/cmp/trait.Eq.html' title='core::cmp::Eq'>Eq</a> for <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'></div><h3 class='impl'><code>impl <a class='trait' href='../glib/object/trait.IsA.html' title='glib::object::IsA'>IsA</a>&lt;<a class='struct' href='../glib/object/struct.Object.html' title='glib::object::Object'>Object</a>&gt; for <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'></div><h3 id='derived_implementations'>Derived Implementations </h3><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html' title='core::hash::Hash'>Hash</a> for <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'><h4 id='method.hash' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash' class='fnname'>hash</a>&lt;__H: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a>&gt;(&amp;self, __arg_0: &amp;mut __H)</code></h4>
<h4 id='method.hash_slice' class='method'><span class="since">1.3.0</span><code>fn <a href='https://doc.rust-lang.org/nightly/core/hash/trait.Hash.html#method.hash_slice' class='fnname'>hash_slice</a>&lt;H&gt;(data: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.slice.html'>&amp;[Self]</a>, state: &amp;mut H) <span class='where'>where H: <a class='trait' href='https://doc.rust-lang.org/nightly/core/hash/trait.Hasher.html' title='core::hash::Hasher'>Hasher</a></span></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#method.fmt' class='fnname'>fmt</a>(&amp;self, __arg_0: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html' title='core::clone::Clone'>Clone</a> for <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h3><div class='impl-items'><h4 id='method.clone' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone' class='fnname'>clone</a>(&amp;self) -&gt; <a class='struct' href='../gdk/struct.Window.html' title='gdk::Window'>Window</a></code></h4>
<h4 id='method.clone_from' class='method'><span class="since">1.0.0</span><code>fn <a href='https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from' class='fnname'>clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "gdk";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>